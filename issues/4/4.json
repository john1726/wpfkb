{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "Hi all, \r\nI want to customize the Key control to be compatible with the main application theme using DevExpress. \r\n\r\n![Image](https://w4vexg.bay.livefilestore.com/y2pEpNAybhPajYtkJSLD5dRTqEPZwnEWIdDcHkXk1KNaOwhIjsvZ4sSy-C84YEl4l1FjoweUHARu1WtliSdvDHEGuHbpqWPSmYFi8mLILsLL7g/Capture.PNG)\r\n\r\nI tried to make OnScreenKey inherit from Button control instead of Border, and then setting the binding of DisplayName to __Button.ContentProperty__, the DisplayName displayed correctly but when i press any key it doesn't work, nothing sent to the Textbox, my customized class is look as the following: \r\n\r\n\r\n\r\n``` C#\r\n\r\n    public class OnScreenKey : Button\r\n    {\r\n        public static readonly DependencyProperty KeyProperty = DependencyProperty.Register(\"Key\", typeof(ILogicalKey), typeof(OnScreenKey), new UIPropertyMetadata(null, OnKeyChanged));\r\n        public static readonly DependencyProperty AreAnimationsEnabledProperty = DependencyProperty.Register(\"AreAnimationsEnabled\", typeof(bool), typeof(OnScreenKey), new UIPropertyMetadata(true));\r\n        public static readonly DependencyProperty IsMouseOverAnimationEnabledProperty = DependencyProperty.Register(\"IsMouseOverAnimationEnabled\", typeof(bool), typeof(OnScreenKey), new UIPropertyMetadata(false));\r\n        public static readonly DependencyProperty IsOnScreenKeyDownProperty = DependencyProperty.Register(\"IsOnScreenKeyDown\", typeof(bool), typeof(OnScreenKey), new UIPropertyMetadata(false));\r\n        public static readonly DependencyProperty GridWidthProperty = DependencyProperty.Register(\"GridWidth\", typeof(GridLength), typeof(OnScreenKey), new UIPropertyMetadata(new GridLength(1, GridUnitType.Star)));\r\n\r\n\r\n        public static readonly RoutedEvent PreviewOnScreenKeyDownEvent = EventManager.RegisterRoutedEvent(\"PreviewOnScreenKeyDown\", RoutingStrategy.Direct, typeof(OnScreenKeyEventHandler), typeof(OnScreenKey));\r\n        public static readonly RoutedEvent PreviewOnScreenKeyUpEvent = EventManager.RegisterRoutedEvent(\"PreviewOnScreenKeyUp\", RoutingStrategy.Direct, typeof(OnScreenKeyEventHandler), typeof(OnScreenKey));\r\n        public static readonly RoutedEvent OnScreenKeyDownEvent = EventManager.RegisterRoutedEvent(\"OnScreenKeyDown\", RoutingStrategy.Direct, typeof(OnScreenKeyEventHandler), typeof(OnScreenKey));\r\n        public static readonly RoutedEvent OnScreenKeyUpEvent = EventManager.RegisterRoutedEvent(\"OnScreenKeyUp\", RoutingStrategy.Direct, typeof(OnScreenKeyEventHandler), typeof(OnScreenKey));\r\n        public static readonly RoutedEvent OnScreenKeyPressEvent = EventManager.RegisterRoutedEvent(\"OnScreenKeyPress\", RoutingStrategy.Direct, typeof(OnScreenKeyEventHandler), typeof(OnScreenKey));\r\n\r\n        public ILogicalKey Key\r\n        {\r\n            get { return (ILogicalKey)GetValue(KeyProperty); }\r\n            set { SetValue(KeyProperty, value); }\r\n        }\r\n\r\n        public bool AreAnimationsEnabled\r\n        {\r\n            get { return (bool)GetValue(AreAnimationsEnabledProperty); }\r\n            set { SetValue(AreAnimationsEnabledProperty, value); }\r\n        }\r\n\r\n        public bool IsMouseOverAnimationEnabled\r\n        {\r\n            get { return (bool)GetValue(IsMouseOverAnimationEnabledProperty); }\r\n            set { SetValue(IsMouseOverAnimationEnabledProperty, value); }\r\n        }\r\n\r\n        public bool IsOnScreenKeyDown\r\n        {\r\n            get { return (bool)GetValue(IsOnScreenKeyDownProperty); }\r\n            private set { SetValue(IsOnScreenKeyDownProperty, value); }\r\n        }\r\n\r\n        public int GridRow\r\n        {\r\n            get { return (int)GetValue(Grid.RowProperty); }\r\n            set { SetValue(Grid.RowProperty, value); }\r\n        }\r\n\r\n        public int GridColumn\r\n        {\r\n            get { return (int)GetValue(Grid.ColumnProperty); }\r\n            set { SetValue(Grid.ColumnProperty, value); }\r\n        }\r\n\r\n        public GridLength GridWidth\r\n        {\r\n            get { return (GridLength)GetValue(GridWidthProperty); }\r\n            set { SetValue(GridWidthProperty, value); }\r\n        }\r\n        \r\n\r\n        \r\n        protected static void OnKeyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)\r\n        {\r\n            ((OnScreenKey)sender).SetupControl((ILogicalKey)e.NewValue);\r\n        }\r\n\r\n        public event OnScreenKeyEventHandler PreviewOnScreenKeyDown\r\n        {\r\n            add { AddHandler(PreviewOnScreenKeyDownEvent, value); }\r\n            remove { RemoveHandler(PreviewOnScreenKeyDownEvent, value); }\r\n        }\r\n\r\n        protected OnScreenKeyEventArgs RaisePreviewOnScreenKeyDownEvent()\r\n        {\r\n            var args = new OnScreenKeyEventArgs(PreviewOnScreenKeyDownEvent, this);\r\n            RaiseEvent(args);\r\n            return args;\r\n        }\r\n\r\n        public event OnScreenKeyEventHandler PreviewOnScreenKeyUp\r\n        {\r\n            add { AddHandler(PreviewOnScreenKeyUpEvent, value); }\r\n            remove { RemoveHandler(PreviewOnScreenKeyUpEvent, value); }\r\n        }\r\n\r\n        protected OnScreenKeyEventArgs RaisePreviewOnScreenKeyUpEvent()\r\n        {\r\n            var args = new OnScreenKeyEventArgs(PreviewOnScreenKeyUpEvent, this);\r\n            RaiseEvent(args);\r\n            return args;\r\n        }\r\n\r\n        public event OnScreenKeyEventHandler OnScreenKeyDown\r\n        {\r\n            add { AddHandler(OnScreenKeyDownEvent, value); }\r\n            remove { RemoveHandler(OnScreenKeyDownEvent, value); }\r\n        }\r\n\r\n        protected OnScreenKeyEventArgs RaiseOnScreenKeyDownEvent()\r\n        {\r\n            var args = new OnScreenKeyEventArgs(OnScreenKeyDownEvent, this);\r\n            RaiseEvent(args);\r\n            return args;\r\n        }\r\n\r\n        public event OnScreenKeyEventHandler OnScreenKeyUp\r\n        {\r\n            add { AddHandler(OnScreenKeyUpEvent, value); }\r\n            remove { RemoveHandler(OnScreenKeyUpEvent, value); }\r\n        }\r\n\r\n        protected OnScreenKeyEventArgs RaiseOnScreenKeyUpEvent()\r\n        {\r\n            var args = new OnScreenKeyEventArgs(OnScreenKeyUpEvent, this);\r\n            RaiseEvent(args);\r\n            return args;\r\n        }\r\n\r\n        public event OnScreenKeyEventHandler OnScreenKeyPress\r\n        {\r\n            add { AddHandler(OnScreenKeyPressEvent, value); }\r\n            remove { RemoveHandler(OnScreenKeyPressEvent, value); }\r\n        }\r\n\r\n        protected OnScreenKeyEventArgs RaiseOnScreenKeyPressEvent()\r\n        {\r\n            var args = new OnScreenKeyEventArgs(OnScreenKeyPressEvent, this);\r\n            RaiseEvent(args);\r\n            return args;\r\n        }\r\n\r\n        private void SetupControl(ILogicalKey key)\r\n        {\r\n            //Here i set the binding\r\n            SetBinding(ContentProperty, new Binding(\"DisplayName\") {Source = key});\r\n            key.PropertyChanged += Key_PropertyChanged;\r\n            key.LogicalKeyPressed += Key_VirtualKeyPressed;\r\n        }\r\n\r\n        void Key_VirtualKeyPressed(object sender, LogicalKeyEventArgs e)\r\n        {\r\n            RaiseOnScreenKeyPressEvent();\r\n        }\r\n\r\n        void Key_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)\r\n        {\r\n            if (Key is ModifierKeyBase && e.PropertyName == \"IsInEffect\")\r\n            {\r\n                var key = ((ModifierKeyBase)Key);\r\n                if (key.IsInEffect)\r\n                {\r\n                    AnimateMouseDown();\r\n                }\r\n                else\r\n                {\r\n                    AnimateMouseUp();\r\n                }\r\n            }\r\n        }\r\n\r\n        protected override void OnMouseDown(MouseButtonEventArgs e)\r\n        {\r\n            HandleKeyDown();\r\n            base.OnMouseDown(e);\r\n        }\r\n\r\n        protected void HandleKeyDown()\r\n        {\r\n            var args = RaisePreviewOnScreenKeyDownEvent();\r\n            if (args.Handled == false)\r\n            {\r\n                IsOnScreenKeyDown = true;\r\n                AnimateMouseDown();\r\n                Key.Press();\r\n            }\r\n            RaiseOnScreenKeyDownEvent();\r\n        }\r\n\r\n        protected override void OnMouseUp(MouseButtonEventArgs e)\r\n        {\r\n            HandleKeyUp();\r\n            base.OnMouseUp(e);\r\n        }\r\n\r\n        private void HandleKeyUp()\r\n        {\r\n            var args = RaisePreviewOnScreenKeyUpEvent();\r\n            if (args.Handled == false)\r\n            {\r\n                IsOnScreenKeyDown = false;\r\n                AnimateMouseUp();\r\n            }\r\n            RaiseOnScreenKeyUpEvent();\r\n        }\r\n\r\n        private void AnimateMouseDown()\r\n        {\r\n\r\n        }\r\n\r\n        private void AnimateMouseUp()\r\n        {\r\n            if ((Key is TogglingModifierKey || Key is InstantaneousModifierKey) && ((ModifierKeyBase)Key).IsInEffect) return;\r\n            if (!AreAnimationsEnabled || Key is TogglingModifierKey || Key is InstantaneousModifierKey)\r\n            {\r\n                \r\n            }\r\n        }\r\n\r\n        protected override void OnMouseEnter(MouseEventArgs e)\r\n        {\r\n            if (IsMouseOverAnimationEnabled)\r\n            {\r\n            }\r\n            base.OnMouseEnter(e);\r\n        }\r\n\r\n        protected override void OnMouseLeave(MouseEventArgs e)\r\n        {\r\n            if (IsMouseOverAnimationEnabled)\r\n            {\r\n                if (Key is TogglingModifierKey && ((ModifierKeyBase)Key).IsInEffect) return;\r\n            }\r\n            if (IsOnScreenKeyDown)\r\n            {\r\n                HandleKeyUp();\r\n            }\r\n            base.OnMouseLeave(e);\r\n        }\r\n    }\r\n```\r\n\r\nHow can i solve the problem please? ",
    "LastUpdatedDate": "2014-06-10T08:22:24.81-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Unassigned",
      "Severity": 0,
      "Id": 0
    },
    "ProjectName": "wpfkb",
    "ReportedDate": "2014-06-10T08:22:24.81-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Change key theme",
    "Type": {
      "Name": "Unassigned",
      "Id": 5
    },
    "VoteCount": 1,
    "Id": 4
  },
  "FileAttachments": [],
  "Comments": []
}